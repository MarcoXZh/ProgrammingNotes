<!DOCTYPE html>
<html>
<head>
  <title> JsTreeNode & JsTree </title>
  <meta http-equiv="Content-Type" content="text/html" charset="utf-8" />
  <script id= "testcode">
    function consoleOutput() {
      var str = "";
      var root = new JsTreeNode("root");
      str += "var root = new JsTreeNode(\"root\");\n";
      var nullNode = new JsTreeNode("null");            // A node not in the tree
      str += "var nullNode = new JsTreeNode(\"null\");\t// A node not in the tree\n";
      var tree = new JsTree(root, "Tree");
      str += "var tree = new JsTree(root, \"Tree\");\n";
      str += "  " + tree.toString().replace(/\n/g, "\n  ") + "\n";
      var c12 = new JsTreeNode("c12");
      str += "var c12 = new JsTreeNode(\"c12\");\n";
      str += "root.appendChild(c12);\t\t\t" + root.appendChild(c12) + "\n";
      var c11 = new JsTreeNode("c11");
      str += "var c11 = new JsTreeNode(\"c11\");\n";
      str += "root.insertBefore(nullNode, c11);\t" + root.insertBefore(nullNode, c11) + "\n";
      str += "root.insertBefore(c12, c11);\t\t" + root.insertBefore(c12, c11) + "\n";
      var c14 = new JsTreeNode("c14");
      str += "var c14 = new JsTreeNode(\"c14\");\n";
      str += "root.appendChild(c14);\t\t\t" + root.appendChild(c14) + "\n";
      str += "  " + tree.toString().replace(/\n/g, "\n  ") + "\n";
      var c13 = new JsTreeNode("c13");
      str += "var c13 = new JsTreeNode(\"c13\");\n";
      str += "root.replaceChild(nullNode, c13);\t" + root.replaceChild(nullNode, c13) + "\n";
      str += "root.replaceChild(c14, c13);\t\t" + root.replaceChild(c14, c13) + "\n";
      str += "  " + tree.toString().replace(/\n/g, "\n  ") + "\n";
      var c21 = new JsTreeNode("c21");
      str += "var c21 = new JsTreeNode(\"c21\");\n";
      var c22 = new JsTreeNode("c22");
      str += "var c22 = new JsTreeNode(\"c22\");\n";
      var c23 = new JsTreeNode("c23");
      str += "var c23 = new JsTreeNode(\"c23\");\n";
      var c24 = new JsTreeNode("c24");
      str += "var c24 = new JsTreeNode(\"c24\");\n";
      var c25 = new JsTreeNode("c25");
      str += "var c25 = new JsTreeNode(\"c25\");\n";
      var c26 = new JsTreeNode("c26");
      str += "var c26 = new JsTreeNode(\"c26\");\n";
      str += "c11.appendChild(c21);\t\t\t" + c11.appendChild(c21) + "\n";
      str += "c11.appendChild(c22);\t\t\t" + c11.appendChild(c22) + "\n";
      str += "  " + tree.toString().replace(/\n/g, "\n  ") + "\n";
      str += "c11.removeChild(nullNode);\t\t" + c11.removeChild(nullNode) + "\n";
      str += "  " + tree.toString().replace(/\n/g, "\n  ") + "\n";
      str += "c11.removeChild(c21);\t\t\t" + c11.removeChild(c21) + "\n";
      str += "c11.removeChild(c21);\t\t\t" + c11.removeChild(c21) + "\n";
      str += "  " + tree.toString().replace(/\n/g, "\n  ") + "\n";
      str += "c12.appendChild(c23);\t\t\t" + c12.appendChild(c23) + "\n";
      str += "c12.appendChild(c23);\t\t\t" + c12.appendChild(c23) + "\n";
      str += "  " + tree.toString().replace(/\n/g, "\n  ") + "\n";
      str += "c12.appendChild(c25);\t\t\t" + c12.appendChild(c25) + "\n";
      str += "  " + tree.toString().replace(/\n/g, "\n  ") + "\n";
      str += "c12.replaceChild(nullNode, c24);\t" + c12.replaceChild(nullNode, c24) + "\n";
      str += "  " + tree.toString().replace(/\n/g, "\n  ") + "\n";
      str += "c12.replaceChild(c25, c24);\t\t" + c12.replaceChild(c25, c24) + "\n";
      str += "  " + tree.toString().replace(/\n/g, "\n  ") + "\n";
      str += "c13.appendChild(c25);\t\t\t" + c13.appendChild(c25) + "\n";
      str += "  " + tree.toString().replace(/\n/g, "\n  ") + "\n";
      str += "c13.appendChild(c26);\t\t\t" + c13.appendChild(c26) + "\n";
      str += "  " + tree.toString().replace(/\n/g, "\n  ") + "\n";
      var c31 = new JsTreeNode("c31");
      str += "var c31 = new JsTreeNode(\"c31\");\n";
      var c41 = new JsTreeNode("c41");
      str += "var c41 = new JsTreeNode(\"c41\");\n";
      str += "c23.appendChild(c31);\t\t\t" + c23.appendChild(c31) + "\n";
      str += "c31.appendChild(c41);\t\t\t" + c31.appendChild(c41) + "\n";
      str += "  " + tree.toString().replace(/\n/g, "\n  ") + "\n\n";

      str += "tree.contains(root);\t\t\t" +  tree.contains(root) + "\n";
      str += "tree.contains(c23);\t\t\t" +  tree.contains(c23) + "\n";
      str += "tree.contains(nullNode);\t\t" +  tree.contains(nullNode) + "\n";
      str += "tree.getNodePath(root);\t\t\t" +  tree.getNodePath(root) + "\n";
      str += "tree.getNodePath(c23);\t\t\t" +  tree.getNodePath(c23) + "\n";
      str += "tree.getNodePath(nullNode);\t\t" +  tree.getNodePath(nullNode) + "\n";
      str += "tree.getNodeDepth(root);\t\t" +  tree.getNodeDepth(root) + "\n";
      str += "tree.getNodeDepth(c23);\t\t\t" +  tree.getNodeDepth(c23) + "\n";
      str += "tree.getNodeDepth(nullNode);\t\t" +  tree.getNodeDepth(nullNode) + "\n";
      str += "tree.getNodeLevel(root);\t\t" +  tree.getNodeLevel(root) + "\n";
      str += "tree.getNodeLevel(c23);\t\t\t" +  tree.getNodeLevel(c23) + "\n";
      str += "tree.getNodeLevel(nullNode);\t\t" +  tree.getNodeLevel(nullNode) + "\n";
      str += "tree.getNodeHeight(root);\t\t" +  tree.getNodeHeight(root) + "\n";
      str += "tree.getNodeHeight(c23);\t\t" +  tree.getNodeHeight(c23) + "\n";
      str += "tree.getNodeHeight(nullNode);\t\t" +  tree.getNodeHeight(nullNode) + "\n";
      str += "tree.getTreeHeight();\t\t\t" +  tree.getTreeHeight() + "\n\n";

      str += "root.removeChild(c12);\t\t\t" +  root.removeChild(c12) + "\n";
      str += "  " + tree.toString().replace(/\n/g, "\n  ") + "\n";
      str += "root.removeChild(c13);\t\t\t" +  root.removeChild(c13) + "\n\n";

      str += "tree.empty();\t\t\t\t" + tree.empty() + "\n";
      str += "tree.isEmpty();\t\t\t\t" +  tree.isEmpty() + "\n";
      str += "  " + tree.toString().replace(/\n/g, "\n  ") + "\n";
      str += "tree.contains(root);\t\t\t" +  tree.contains(root) + "\n";
      str += "tree.contains(nullNode);\t\t" +  tree.contains(nullNode) + "\n";
      str += "tree.contains(null);\t\t\t" +  tree.contains(null) + "\n";
      document.getElementById("output").innerHTML = str;
    } // function consoleOutput()
  </script>
  <script>
    function showCodes() {
      var node = document.getElementById("source-jstree");
      var innerHTML = document.getElementById("jstree").innerHTML;
      node.innerHTML = innerHTML.trim().replace(/\n    /g, "\n");

      node = document.getElementById("source-jstreenode");
      innerHTML = document.getElementById("jstreenode").innerHTML;
      node.innerHTML = innerHTML.trim().replace(/\n    /g, "\n");

      node = document.getElementById("test");
      innerHTML = document.getElementById("testcode").innerHTML;
      node.innerHTML = innerHTML.trim().replace(/\n    /g, "\n");
    } // function showCodes()
  </script>
</head>
<body onload="consoleOutput(); showCodes();">
  <div style="margin:8px; float:left; width:45%;">
    <p style="font-weight:bold;">Source Code - TreeNode</p>
    <pre id="source-jstreenode" style="border:1px solid; padding:8px; overflow:scroll; height:500px;"></pre>
  </div>
  <div style="margin:8px; float:left; width:45%; top:600px; position:absolute;">
    <p style="font-weight:bold;">Source Code - Tree</p>
    <pre id="source-jstree" style="border:1px solid; padding:8px; overflow:scroll; height:500px;"></pre>
  </div>
  <div style="margin:8px; float:right; width:52%;">
    <p style="font-weight:bold;">Console Output</p>
    <pre id="output" style="border:1px solid; padding:8px; overflow:scroll; height:500px;"></pre>
  </div>
  <div style="margin:8px; float:right; width:52%; top:600px;">
    <p style="font-weight:bold;">Test Code</p>
    <pre id="test" style="border:1px solid; padding:8px; overflow:scroll; height:500px;"></pre>
  </div>
  <script id="jstreenode">
    /**
     * JavaScript Implementation of "JsTreeNode" class
     * @author  MarcoXZh
     * @version 2.0
     */
    function JsTreeNode(name) {
      this.nodeName = name;
      this.parent = null;
      this.childCount = 0;
      this.children = [];
      this.firstChild = null;
      this.lastChild = null;
      this.nextSibling = null;
      this.previousSibling = null;

      /**
       * Find out the index of "child" from children list of "node"
       * @param node        {JsTreeNode} the parent node to be searched
       * @param child       {JsTreeNode} the target node
       * @return            {Number} the index of the node; -1 means not found
       */
      var findChild = function(node, child) {
        if (!child || child.constructor.name !== node.constructor.name)
          return -1;
        for (i in node.children)
          if (node.children[i] === child)
            return parseInt(i);
        return -1;
      }; // var findChild = function(root, child) {...};

      /**
       * Append a new child node to this node
       * @param child       {JsTreeNode} the new child node
       * @return            {Boolean} true for succed; false for fail
       */
      this.appendChild = function(child) {
        if (findChild(this, child) !== -1)
          return false;
        this.childCount = this.children.push(child);
        this.lastChild = child;
        if (this.childCount === 1) {
          this.firstChild = child;
          child.previousSibling = null;
        } else {
          child.previousSibling = this.children[this.childCount - 2];
          this.children[this.childCount - 2].nextSibling = child;
        } // else - if (this.childCount === 1)
        child.parent = this;
        child.nextSibling = null;
        return true;
      }; // this.appendChild = function(child) {...};

      /**
       * Insert a new child before an existing child
       * @param curChild    {JsTreeNode} the existing child
       * @param newChild    {JsTreeNode} the new child
       * @return            {Boolean} true for succed; false for fail
       */
      this.insertBefore = function(curChild, newChild) {
        var index = findChild(this, curChild);
        if (index < 0)
          return false;
        this.children.splice(index, 0, newChild);
        this.childCount ++;
        newChild.parent = this;
        if (index === 0) {
          this.firstChild = newChild;
          newChild.previousSibling = null;
        } else {
          newChild.previousSibling = this.chilren[index - 1];
          this.chilren[index - 1].nextSibling = newChild;
        } // else - if (index === 0)
        newChild.nextSibling = curChild;
        curChild.previousSibling = newChild;
        return true;
      }; // this.insertBefore = function(curChild, newChild) {...};

      /**
       * Remove an existing child
       * @param child       {JsTreeNode} the child to be removed
       * @return            {Boolean} true for succed; false for fail
       */
      this.removeChild = function(child) {
        var index = findChild(this, child);
        if (index < 0)
          return false;
        this.children.splice(index, 1);
        this.childCount --;
        this.firstChild = this.childCount === 0 ? null : this.children[0];
        this.lastChild = this.childCount === 0 ?
                         null : this.children[this.childCount - 1];
        if (child.nextSibing)
          child.nextSibing.previousSibling = child.previousSibing;
        if (child.previousSibing)
          child.previousSibing.nextSibling = child.nextSibing;
        child.parent = null;
        child.nextSibling = null;
        child.previousSibling = null;
        return true;
      }; // this.removeChild = function(child) {...};

      /**
       * Replace an existing child with the new child before
       * @param curChild    {JsTreeNode} the existing child
       * @param newChild    {JsTreeNode} the new child
       * @return            {Boolean} true for succed; false for fail
       */
      this.replaceChild = function(curChild, newChild) {
        var index = findChild(this, curChild);
        if (index < 0)
          return false;
        this.children.splice(index, 1, newChild);
        newChild.parent = this;
        if (index === 0)
          this.firstChild = newChild;
        else if (index === this.childCount - 1)
          this.lastChild = newChild;
        newChild.previousSibling = curChild.previousSibling;
        newChild.nextSibling = curChild.nextSibling;
        if (curChild.nextSibling)
          curChild.nextSibling.previousSibling = newChild;
        if (curChild.previousSibling)
          curChild.previousSibling.nextSibling = newChild;
        curChild.parent = null;
        curChild.nextSibling = null;
        curChild.previousSibling = null;
        return true;
      }; // this.replaceChild = function(curChild, newChild) {...};

      /**
       * Check if the node contains an immediate child
       * @param child       {JsTreeNode} the child to be searched
       * @return            {Boolean} true for existing; false for not
       */
      this.contains = function(child) {
        return findChild(this, child) !== -1;
      }; // this.contains = function(child) {...};

      /**
       * Cast the node into a string
       * @return            {String} string representation of the node
       */
      this.toString = function() {
        var str = this.nodeName +
                  ": parent=" + (this.parent == null ?
                                 "null" : this.parent.nodeName) +
                  ";prev=" + (this.previousSibling ?
                              this.previousSibling.nodeName : "null") +
                  ";next=" + (this.nextSibling ?
                              this.nextSibling.nodeName : "null") +
                  "; children(" + this.childCount + ")=[";
        for (i in this.children)
          str += this.children[i].nodeName + ", ";
        if (this.childCount > 0)
          str = str.substr(0, str.length - 2);
        str += "]:first=" + (this.firstChild ? this.firstChild.nodeName : "null") +
               ";last=" + (this.lastChild ? this.lastChild.nodeName : "null");
        return str;
      }; // this.toString = function() {...};

    } // function JsTreeNode(name)
  </script>

  <script id="jstree">
    /**
     * JavaScript Implementation of "JsTree" class
     * @author  MarcoXZh
     * @version 2.0
     */
    function JsTree(treeRoot, name) {
      this.treeName = name;
      this.root = treeRoot;

      /**
       * Remove all nodes frome the tree
       * @return            {Boolean} true for succed; false for fail
       */
      this.empty = function() {
        this.root = null;
        return true;
      }; // this.empty = function() {...};

      /**
       * Check if the tree is empty
       * @return            {Boolean} true for empty; false for not
       */
      this.isEmpty = function() {
        return this.root === null || this.root === undefined;
      }; // this.isEmpty = function() {...};

      /**
       * Find if the node is in the sub tree
       * @param root        {JsTreeNode} root node of the sub tree
       * @param node        {JsTreeNode} the target node to be searched
       * @return            {Boolean} true for found; false for not
       */
      var hasNode = function(root, node) {
        if (root === node)
          return true;
        var index = 0;
        while (index++ < root.childCount)
          if (hasNode(root.children[index - 1], node))
            return true;
        return false;
      }; // var hasNode = function(root, node) {...};

      /**
       * Find if the node is in the tree
       * @param node        {JsTreeNode} the target node to be searched
       * @return            {Boolean} true for found; false for not
       */
      this.contains = function(node) {
        return !(!node) && !this.isEmpty() && hasNode(this.root, node);
      }; // this.contains = function(node) {...};

      /**
       * Return the path of a node
       * @param node        {JsTreeNode} the target node to be searched
       * @return            {String} path of the node; null means not in the tree
       */
      this.getNodePath = function(node) {
        if (!node || this.isEmpty() || !hasNode(this.root, node))
          return null;
        var path = "/" + node.nodeName;
        var parent = node.parent;
        while (parent) {
          path = "/" + parent.nodeName + path;
          parent = parent.parent;
        } // while (parent)
        return path;
      }; // this.getNodePath = function(node) {...};

      /**
       * Find the depth of a node:
       * number of edges from the node to the root
       * @param node        {JsTreeNode} the target node to be searched
       * @return            {Number} depth of the node; -1 means not in the tree
       */
      this.getNodeDepth = function(node) {
        if (!node || this.isEmpty() || !hasNode(this.root, node))
          return -1;
        var parent = node.parent;
        var depth = 0;
        while (parent) {
          depth ++;
          parent = parent.parent;
        } // while (parent)
        return depth;
      }; // this.getNodeDepth = function(node) {...};

      /**
       * Find the level of a node:
       * 1 + number of edges between the node and the root
       * @param node        {JsTreeNode} the target node to be searched
       * @return            {Number} level of the node; -1 means not in the tree
       */
      this.getNodeLevel = function(node) {
        return (!node || this.isEmpty() || !hasNode(this.root, node)) ?
                -1 : this.getNodeDepth(node) + 1;
      }; // this.getNodeLevel = function(node) {...};

      /**
       * Find the height of a node (assume it's in the tree):
       * number of edges on the longest downward path between the node and a leaf
       * @param node        {JsTreeNode} the target node to be searched
       * @return            {Number} height of the node
       */
      var getHeight = function(node) {
        if (node.childCount === 0)
          return 0;
        var height = 0, index = 0;
        while (index++ < node.childCount) {
          var h = getHeight(node.children[index - 1]);
          if (h > height)
            height = h;
        } // while (index++ < node.childCount)
        return height + 1;
      }; // var getHeight = function(node) {...};

      /**
       * Find the height of a node:
       * number of edges on the longest downward path between the node and a leaf
       * @param node        {JsTreeNode} the target node to be searched
       * @return            {Number} height of the node; -1 means not in the tree
       */
      this.getNodeHeight = function(node) {
        return (!node || this.isEmpty() || !hasNode(this.root, node)) ?
                -1 : getHeight(node);
      }; // this.getNodeHeight = function(node) {...};

      /**
       * Find the height of the tree:
       * number of edges on the longest downward path between the root and a leaf
       * @param node        {JsTreeNode} the target node to be searched
       * @return            {Number} height of the tree
       */
      this.getTreeHeight = function() {
        return this.isEmpty() ? 0 : getHeight(this.root);
      }; // this.getTreeHeight = function() {...};

      /**
       * Cast a sub tree to into a string with proper indentation
       * @param root        {JsTreeNode} root of the sub tree
       * @return            {String} string representation of the sub tree
       */
      var getNodeString = function(root, level) {
        var str = "  ";
        var index = 0;
        while (index++ < level)
          str += "| ";
        if (str.length != 2)
          str = str.substr(0, str.length - 1) + "-";
        str += root.toString() + "\n";
        index = 0;
        while (index++ < root.childCount)
          str += getNodeString(root.children[index - 1], level + 1);
        return str;
      }; // var getNodeString = function(node, level) {...};

      /**
       * Cast the tree into a string
       * @return            {String} string representation of the tree
       */
      this.toString = function() {
        if (this.isEmpty())
          return "{Empty}";
        var str = "== " + this.constructor.name + ": \"" + this.treeName + "\" ==\n";
        str += getNodeString(this.root, 0);
        str += "== " + this.constructor.name + ": \"" + this.treeName + "\" ==";
        return str;
      }; // this.toString = function() {...};

    } // function JsTree(treeRoot, name)
  </script>
</body>
</html>
